<!DOCTYPE html>
<!-- saved from url=(0079)https://tech.meituan.com/2018/11/01/swift-compile-performance-optimization.html -->
<html lang="en" dir="ltr" class=" theme-united"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="renderer" content="webkit"><meta http-equiv="x-ua-compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="author" content="soulteary@gmail.com"><script type="text/javascript" async="" src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/analytics.js"></script><script type="text/javascript" async="" src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/js"></script><script type="text/javascript" async="" src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/analytics.js"></script><script src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/hm.js"></script><script async="" src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/js(1)"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-158867676-1');</script><meta name="robots" content="index, follow"><meta property="og:title" content="【基本功】深入剖析Swift性能优化"><meta property="og:description" content="Swift具有快速、灵活、安全的特性。通过编译器的优化使得执行速度更快，占用空间更小。本文将介绍Swift编译器在各阶段如何优化代码以及方法是如何分配的，在此基础上，引申出如何利用这些优化特性，选择正确的机制来提高程序性能。 文末扩展了Swift在优化后出现的一些非预期的“Bug”。"><meta property="og:type" content="article"><meta property="og:url" content="https://tech.meituan.com/2018/11/01/swift-compile-performance-optimization.html"><meta property="article:published_time" content="2018-11-01T00:00:00+00:00"><meta property="article:modified_time" content="2018-11-01T00:00:00+00:00"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【基本功】深入剖析Swift性能优化"><meta name="twitter:description" content="Swift具有快速、灵活、安全的特性。通过编译器的优化使得执行速度更快，占用空间更小。本文将介绍Swift编译器在各阶段如何优化代码以及方法是如何分配的，在此基础上，引申出如何利用这些优化特性，选择正确的机制来提高程序性能。 文末扩展了Swift在优化后出现的一些非预期的“Bug”。"><meta name="description" content="Swift具有快速、灵活、安全的特性。通过编译器的优化使得执行速度更快，占用空间更小。本文将介绍Swift编译器在各阶段如何优化代码以及方法是如何分配的，在此基础上，引申出如何利用这些优化特性，选择正确的机制来提高程序性能。 文末扩展了Swift在优化后出现的一些非预期的“Bug”。"><meta name="keywords" content="前端,到店,iOS,Swift,编译器,Static dispatch,Dynamic dispatch,Compile 0ptimization,"><link rel="canonical" href="https://tech.meituan.com/2018/11/01/swift-compile-performance-optimization.html"><title>【基本功】深入剖析Swift性能优化 - 美团技术团队</title><link rel="stylesheet" href="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/common.css"><link rel="stylesheet" href="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/post.css"><link rel="apple-touch-icon" sizes="180x180" href="https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/apple-icon-180x180.png?v=Whistle&amp;t=20181017-1r"><link rel="icon" type="image/png" sizes="192x192" href="https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/android-icon-192x192.png?v=Whistle&amp;t=20181017-1r"><link rel="shortcut icon" href="https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&amp;t=20181017-1r"><script>top!=self&&top.host!=self.host&&(top.location=self.location);(function(d){d.className=d.className.replace(/\bno-js/,'');})(document.documentElement);var $CONFIG={'data':{}};</script><link href="https://tech.meituan.com/feed/" rel="alternate" type="application/rss+xml" title="【基本功】深入剖析Swift性能优化"><script src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/zepto.min.js"></script><script src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/common.js"></script></head><body class="page page-type-post" data-new-gr-c-s-check-loaded="14.1098.0" data-gr-ext-installed=""><nav class="navbar navbar-default g-navbar-box hidden-print" id="Js_page-navbar"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
<span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button>
<a class="navbar-brand" href="https://tech.meituan.com/" title="美团技术团队" target="_self">美团技术团队</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right" id="JS_nav_list"><li class="menu-item menu-item-home"><a class="menu-item-link" href="https://tech.meituan.com/" target="_self" title="查看最新文章">最新文章</a></li><li class="menu-item menu-item-archive"><a class="menu-item-link" href="https://tech.meituan.com/archives" target="_self" title="查看文章存档内容">文章存档</a></li><li class="menu-item menu-item-salon"><a class="menu-item-link" href="https://tech.meituan.com/tech-salon" target="_self" title="了解技术沙龙">技术沙龙</a></li><li class="menu-item menu-item-about"><a class="menu-item-link" href="https://tech.meituan.com/about" target="_self" title="了解更多关于我们的事情">关于我们</a></li></ul></div><div class="navbar-bottom"><p class="copyright">© 2023 美团技术团队</p><p class="copyright">All rights reserved.</p></div></nav><div class="container-fluid main-container" id="J_main-container"><div class="row"><div class="col-md-12"><div class="post-container"><h1 class="post-title"><a href="https://tech.meituan.com/2018/11/01/swift-compile-performance-optimization.html" rel="bookmark">【基本功】深入剖析Swift性能优化</a></h1><div class="meta-box"><span class="m-post-date"><i class="fa fa-calendar-o"></i>2018年11月01日</span>
<span class="m-post-nick">作者: 亚男</span>
<span class="m-post-permalink"><i class="fa fa-link-o"></i><a href="https://tech.meituan.com/2018/11/01/swift-compile-performance-optimization.html" target="_blank">文章链接</a></span>
<span class="m-post-count"><i class="fa fa-pencil"></i>17448字</span>
<span class="m-post-reading"><i class="fa fa-hourglass-start"></i>35分钟阅读</span></div><div class="post-content"><div class="content"><h2 id="简介">简介</h2><p>2014年，苹果公司在WWDC上发布Swift这一新的编程语言。经过几年的发展，Swift已经成为iOS开发语言的“中流砥柱”，Swift提供了非常灵活的高级别特性，例如协议、闭包、泛型等，并且Swift还进一步开发了强大的SIL（Swift Intermediate Language）用于对编译器进行优化，使得Swift相比Objective-C运行更快性能更优，Swift内部如何实现性能的优化，我们本文就进行一下解读，希望能对大家有所启发和帮助。</p><p>针对Swift性能提升这一问题，我们可以从概念上拆分为两个部分：</p><ol><li><strong>编译器</strong>：Swift编译器进行的性能优化，从阶段分为编译期和运行期，内容分为时间优化和空间优化。</li><li><strong>开发者</strong>：通过使用合适的数据结构和关键字，帮助编译器获取更多信息，进行优化。</li></ol><p>下面我们将从这两个角度切入，对Swift性能优化进行分析。通过了解编译器对不同数据结构处理的内部实现，来选择最合适的算法机制，并利用编译器的优化特性，编写高性能的程序。</p><h2 id="理解swift的性能">理解Swift的性能</h2><p>理解Swift的性能，首先要清楚Swift的数据结构，组件关系和编译运行方式。</p><ul><li><strong>数据结构</strong></li></ul><p>Swift的数据结构可以大体拆分为：<code>Class</code>，<code>Struct</code>，<code>Enum</code>。</p><ul><li><strong>组件关系</strong></li></ul><p>组件关系可以分为：<code>inheritance</code>，<code>protocols</code>，<code>generics</code>。</p><ul><li><strong>方法分派方式</strong></li></ul><p>方法分派方式可以分为<code>Static dispatch</code>和<code>Dynamic dispatch</code>。</p><p>要在开发中提高Swift性能，需要开发者去了解这几种数据结构和组件关系以及它们的内部实现，从而通过选择最合适的抽象机制来提升性能。</p><p>首先我们对于性能标准进行一个概念陈述，性能标准涵盖三个标准：</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/9543d745.png" alt="性能指标"><div class="img-figure"><span>性能指标</span></div></p><ul><li>Allocation</li><li>Reference counting</li><li>Method dispatch</li></ul><p>接下来，我们会分别对这几个指标进行说明。</p><h3 id="allocation">Allocation</h3><p>内存分配可以分为堆区栈区，在栈的内存分配速度要高于堆，结构体和类在堆栈分配是不同的。</p><p><strong>Stack</strong></p><p>基本数据类型和结构体默认在栈区，栈区内存是连续的，通过出栈入栈进行分配和销毁，速度很快，高于堆区。</p><p>我们通过一些例子进行说明：</p><pre><code class="hljs swift"><span class="hljs-comment"><span class="hljs-comment">//示例 1</span></span>
<span class="hljs-comment"><span class="hljs-comment">// Allocation</span></span>
<span class="hljs-comment"><span class="hljs-comment">// Struct</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y:<span class="hljs-type"><span class="hljs-type">Double</span></span>
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { … }
}
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x:<span class="hljs-number"><span class="hljs-number">0</span></span>, y:<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//进行point1初始化，开辟栈内存</span></span>
<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> point2 = point1 <span class="hljs-comment"><span class="hljs-comment">//初始化point2，拷贝point1内容，开辟新内存</span></span>
point2.x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">//对point2的操作不会影响point1</span></span>
<span class="hljs-comment"><span class="hljs-comment">// use `point1`</span></span>
<span class="hljs-comment"><span class="hljs-comment">// use `point2`</span></span>
</code></pre><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/cb771a53.png" alt="结构体的内存分配"><div class="img-figure"><span>结构体的内存分配</span></div></p><p>以上结构体的内存是在栈区分配的，内部的变量也是内联在栈区。将<code>point1</code>赋值给<code>point2</code>实际操作是在栈区进行了一份拷贝，产生了新的内存消耗<code>point2</code>，这使得<code>point1</code>和<code>point2</code>是完全独立的两个实例，它们之间的操作互不影响。在使用<code>point1</code>和<code>point2</code>之后，会进行销毁。</p><p><strong>Heap</strong></p><p>高级的数据结构，比如类，分配在堆区。初始化时查找没有使用的内存块，销毁时再从内存块中清除。因为堆区可能存在多线程的操作问题，为了保证线程安全，需要进行加锁操作，因此也是一种性能消耗。</p><pre><code class="hljs swift"><span class="hljs-comment"><span class="hljs-comment">// Allocation</span></span>
<span class="hljs-comment"><span class="hljs-comment">// Class</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y:<span class="hljs-type"><span class="hljs-type">Double</span></span>
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { … }
}
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x:<span class="hljs-number"><span class="hljs-number">0</span></span>, y:<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//在堆区分配内存，栈区只是存储地址指针</span></span>
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point2 = point1 <span class="hljs-comment"><span class="hljs-comment">//不产生新的实例，而是对point2增加对堆区内存引用的指针</span></span>
point2.x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">//因为point1和point2是一个实例，所以point1的值也会被修改</span></span>
<span class="hljs-comment"><span class="hljs-comment">// use `point1`</span></span>
<span class="hljs-comment"><span class="hljs-comment">// use `point2`</span></span>
</code></pre><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/3101e25f.png" alt="Class 实例内存分配"><div class="img-figure"><span>Class 实例内存分配</span></div></p><p>以上我们初始化了一个<code>Class</code>类型，在栈区分配一块内存，但是和结构体直接在栈内存储数值不同，我们只在栈区存储了对象的指针，指针指向的对象的内存是分配在堆区的。需要注意的是，为了管理对象内存，在堆区初始化时，除了分配属性内存（这里是Double类型的x，y），还会有额外的两个字段，分别是<code>type</code>和<code>refCount</code>，这个包含了<code>type</code>，<code>refCount</code>和实际属性的结构被称为<code>blue box</code>。</p><p><strong>内存分配总结</strong></p><p>从初始化角度，<code>Class</code>相比<code>Struct</code>需要在堆区分配内存，进行内存管理，使用了指针，有更强大的特性，但是性能较低。</p><p><strong>优化方式：</strong></p><p>对于频繁操作（比如通信软件的内容气泡展示），尽量使用<code>Struct</code>替代<code>Class</code>，因为栈内存分配更快，更安全，操作更快。</p><h3 id="reference-counting">Reference counting</h3><p>Swift通过引用计数管理堆对象内存，当引用计数为0时，Swift确认没有对象再引用该内存，所以将内存释放。对于引用计数的管理是一个非常高频的间接操作，并且需要考虑线程安全，使得引用计数的操作需要较高的性能消耗。</p><p>对于基本数据类型的<code>Struct</code>来说，没有堆内存分配和引用计数的管理，性能更高更安全，但是对于复杂的结构体，如：</p><pre><code class="hljs swift"><span class="hljs-comment"><span class="hljs-comment">// Reference Counting</span></span>
<span class="hljs-comment"><span class="hljs-comment">// Struct containing references</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text:<span class="hljs-type"><span class="hljs-type">String</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> font:<span class="hljs-type"><span class="hljs-type">UIFont</span></span>
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { … }
}
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label1 = <span class="hljs-type"><span class="hljs-type">Label</span></span>(text:<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>, font:font)  <span class="hljs-comment"><span class="hljs-comment">//栈区包含了存储在堆区的指针</span></span>
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label2 = label1 <span class="hljs-comment"><span class="hljs-comment">//label2产生新的指针，和label1一样指向同样的string和font地址</span></span>
<span class="hljs-comment"><span class="hljs-comment">// use `label1`</span></span>
<span class="hljs-comment"><span class="hljs-comment">// use `label2`</span></span>
</code></pre><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/80057f9c.png" alt="结构体包含引用类型"><div class="img-figure"><span>结构体包含引用类型</span></div></p><p>这里看到，包含了引用的结构体相比<code>Class</code>，需要管理双倍的引用计数。每次将结构体作为参数传递给方法或者进行直接拷贝时，都会出现多份引用计数。下图可以比较直观的理解：</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/d2438687.png" alt=""></p><p>备注：包含引用类型的结构体出现Copy的处理方式</p><p>Class在拷贝时的处理方式：</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/20750021.png" alt=""></p><p><strong>引用计数总结</strong></p><ul><li><code>Class</code>在堆区分配内存，需要使用引用计数器进行内存管理。</li><li>基本类型的<code>Struct</code>在栈区分配内存，无引用计数管理。</li><li>包含强类型的<code>Struct</code>通过指针管理在堆区的属性，对结构体的拷贝会创建新的栈内存，创建多份引用的指针，<code>Class</code>只会有一份。</li></ul><p><strong>优化方式</strong></p><p>在使用结构体时：</p><ol><li>通过使用精确类型，例如UUID替代String（UUID字节长度固定128字节，而不是String任意长度），这样就可以进行内存内联，在栈内存储UUID，我们知道，栈内存管理更快更安全，并且不需要引用计数。</li><li>Enum替代String，在栈内管理内存，无引用计数，并且从语法上对于开发者更友好。</li></ol><h3 id="method-dispatch">Method Dispatch</h3><p>我们之前在<a href="https://www.jianshu.com/p/e0659093eaac">Static dispatch VS Dynamic dispatch<i class="fa fa-link" aria-hidden="true"></i></a>中提到过，能够在编译期确定执行方法的方式叫做静态分派Static dispatch，无法在编译期确定，只能在运行时去确定执行方法的分派方式叫做动态分派Dynamic dispatch。</p><p><code>Static dispatch</code>更快，而且静态分派可以进行<strong>内联</strong>等进一步的优化，使得执行更快速，性能更高。</p><p>但是对于多态的情况，我们不能在编译期确定最终的类型，这里就用到了<code>Dynamic dispatch</code>动态分派。动态分派的实现是，每种类型都会创建一张表，表内是一个包含了方法指针的数组。动态分派更灵活，但是因为有查表和跳转的操作，并且因为很多特点对于编译器来说并不明确，所以相当于block了编译器的一些后期优化。所以速度慢于<code>Static dispatch</code>。</p><p>下面看一段多态代码，以及分析实现方式：</p><pre><code class="hljs swift"><span class="hljs-comment"><span class="hljs-comment">//引用语义实现的多态</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y:<span class="hljs-type"><span class="hljs-type">Double</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { … }
}
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2:<span class="hljs-type"><span class="hljs-type">Double</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { … }
}
<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables:[<span class="hljs-type"><span class="hljs-type">Drawable</span></span>]
<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables {
 d.draw（）
}
</code></pre><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/dc4e1465.png" alt="引用语义多态的方法分派流程"><div class="img-figure"><span>引用语义多态的方法分派流程</span></div></p><p><strong>Method Dispatch总结</strong></p><p><code>Class</code>默认使用<code>Dynamic dispatch</code>，因为在编译期几乎每个环节的信息都无法确定，所以阻碍了编译器的优化，比如<code>inline</code>和<code>whole module inline</code>。</p><p><strong>使用Static dispatch代替Dynamic dispatch提升性能</strong></p><p>我们知道<code>Static dispatch</code>快于<code>Dynamic dispatch</code>，如何在开发中去尽可能使用<code>Static dispatch</code>。</p><ul><li><p><code>inheritance constraints</code>继承约束
我们可以使用<code>final</code>关键字去修饰<code>Class</code>，以此生成的<code>Final class</code>，使用<code>Static dispatch</code>。</p></li><li><p><code>access control</code>访问控制
<code>private</code>关键字修饰，使得方法或属性只对当前类可见。编译器会对方法进行<code>Static dispatch</code>。</p></li></ul><p>编译器可以通过<code>whole module optimization</code>检查继承关系，对某些没有标记<code>final</code>的类通过计算，如果能在编译期确定执行的方法，则使用<code>Static dispatch</code>。
<code>Struct</code>默认使用<code>Static dispatch</code>。</p><p>Swift快于OC的一个关键是可以消解动态分派。</p><p><strong>总结</strong></p><p>Swift提供了更灵活的<code>Struct</code>，用以在内存、引用计数、方法分派等角度去进行性能的优化，在正确的时机选择正确的数据结构，可以使我们的代码性能更快更安全。</p><p><strong>延伸</strong></p><p>你可能会问<code>Struct</code>如何实现多态呢?答案是<code>protocol oriented programming</code>。</p><p>以上分析了影响性能的几个标准，那么不同的算法机制<code>Class</code>，<code>Protocol Types</code>和<code>Generic code</code>，它们在这三方面的表现如何，<code>Protocol Type</code>和<code>Generic code</code>分别是怎么实现的呢？我们带着这个问题看下去。</p><h2 id="protocol-type">Protocol Type</h2><p>这里我们会讨论Protocol Type如何存储和拷贝变量，以及方法分派是如何实现的。不通过继承或者引用语义的多态：</p><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y:<span class="hljs-type"><span class="hljs-type">Double</span></span>
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { … }
}
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2:<span class="hljs-type"><span class="hljs-type">Double</span></span>
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { … }
}

<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables:[<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-comment"><span class="hljs-comment">//遵守了Drawable协议的类型集合，可能是point或者line</span></span>
<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables {
 d.draw（）
}
</code></pre><p>以上通过<code>Protocol Type</code>实现多态，几个类之间没有继承关系，故不能按照惯例借助<code>V-Table</code>实现动态分派。</p><p>如果想了解<a href="https://www.jianshu.com/p/c93d7a7d6771">Vtable和Witness table实现<i class="fa fa-link" aria-hidden="true"></i></a>，可以进行点击查看，这里不做细节说明。</p><p>因为Point和Line的尺寸不同，数组存储数据实现一致性存储，使用了<code>Existential Container</code>。查找正确的执行方法则使用了 <code>Protoloc Witness Table</code> 。</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/aa9e8eab.png" alt=""></p><h3 id="existential-container">Existential Container</h3><p><code>Existential Container</code>是一种特殊的内存布局方式，用于管理遵守了相同协议的数据类型<code>Protocol Type</code>，这些数据类型因为不共享同一继承关系（这是<code>V-Table</code>实现的前提），并且内存空间尺寸不同，使用<code>Existential Container</code>进行管理，使其具有存储的一致性。</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/b2b3807e.png" alt="Existential Container的构成"><div class="img-figure"><span>Existential Container的构成</span></div></p><p><strong>结构如下：</strong></p><ul><li>三个词大小的valueBuffer
这里介绍一下valueBuffer结构，valueBuffer有三个词，每个词包含8个字节，存储的可能是值，也可能是对象的指针。对于small value（空间小于valueBuffer），直接存储在valueBuffer的地址内， inline valueBuffer，无额外堆内存初始化。当值的数量大于3个属性即large value，或者总尺寸超过valueBuffer的占位，就会在堆区开辟内存，将其存储在堆区，valueBuffer存储内存指针。</li><li>value witness table的引用
因为<code>Protocol Type</code>的类型不同，内存空间，初始化方法等都不相同，为了对<code>Protocol Type</code>生命周期进行专项管理，用到了<code>Value Witness Table</code>。</li><li>protocol witness table的引用
管理<code>Protocol Type</code>的方法分派。</li></ul><p><strong>内存分布如下：</strong></p><pre><code class="hljs rust"><span class="hljs-number"><span class="hljs-number">1</span></span>. payload_data_0 = <span class="hljs-number"><span class="hljs-number">0x0000000000000004</span></span>,
<span class="hljs-number"><span class="hljs-number">2</span></span>. payload_data_1 = <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span>,
<span class="hljs-number"><span class="hljs-number">3</span></span>. payload_data_2 = <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span>,
<span class="hljs-number"><span class="hljs-number">4</span></span>. instance_type = <span class="hljs-number"><span class="hljs-number">0x000000010d6dc408</span></span> ExistentialContainers`<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">    
       </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">metadata</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ExistentialContainers.Car,
<span class="hljs-number"><span class="hljs-number">5</span></span>. protocol_witness_0 = <span class="hljs-number"><span class="hljs-number">0x000000010d6dc1c0</span></span> 
       ExistentialContainers protocol witness table <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 
       ExistentialContainers.Car:ExistentialContainers.Drivable 
       <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ExistentialContainers
</code></pre><h3 id="protocol-witness-table-pwt">Protocol Witness Table（PWT）</h3><p>为了实现<code>Class</code>多态也就是引用语义多态，需要<code>V-Table</code>来实现，但是<code>V-Table</code>的前提是具有同一个父类即共享相同的继承关系，但是对于<code>Protocol Type</code>来说，并不具备此特征，故为了支持<code>Struct</code>的多态，需要用到<code>protocol oriented programming</code>机制，也就是借助<code>Protocol Witness Table</code>来实现（细节可以点击<a href="https://www.jianshu.com/p/c93d7a7d6771">Vtable和witness table实现<i class="fa fa-link" aria-hidden="true"></i></a>，每个结构体会创造<code>PWT</code>表，内部包含指针，指向方法具体实现）。</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/ced90c8e.png" alt="Point and Line PWT"><div class="img-figure"><span>Point and Line PWT</span></div></p><h3 id="value-witness-table-vwt">Value Witness Table（VWT）</h3><p>用于管理任意值的初始化、拷贝、销毁。</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/ce2a6d93.png" alt="VWT use existential container"><div class="img-figure"><span>VWT use existential container</span></div></p><ul><li><p><code>Value Witness Table</code>的结构如上，是用于管理遵守了协议的<code>Protocol Type</code>实例的初始化，拷贝，内存消减和销毁的。</p></li><li><p><code>Value Witness Table</code>在<code>SIL</code>中还可以拆分为<code>%relative_vwtable</code>和<code>%absolute_vwtable</code>，我们这里先不做展开。</p></li><li><p><code>Value Witness Table</code>和<code>Protocol Witness Table</code>通过分工，去管理<code>Protocol Type</code>实例的内存管理（初始化，拷贝，销毁）和方法调用。</p></li></ul><p>我们来借助具体的示例进行进一步了解：</p><pre><code class="hljs swift"><span class="hljs-comment"><span class="hljs-comment">// Protocol Types</span></span>
<span class="hljs-comment"><span class="hljs-comment">// The Existential Container in action</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local ：Drawable)</span></span></span></span> {
 local.draw()
}
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> val :<span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>()
drawACopy(val)
</code></pre><p>在Swift编译器中，通过<code>Existential Container</code>实现的伪代码如下：</p><pre><code class="hljs swift"><span class="hljs-comment"><span class="hljs-comment">// Protocol Types</span></span>
<span class="hljs-comment"><span class="hljs-comment">// The Existential Container in action</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local :Drawable)</span></span></span></span> {
 local.draw()
}
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> val :<span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>()
drawACopy(val)

<span class="hljs-comment"><span class="hljs-comment">//existential container的伪代码结构</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExistContDrawable</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBuffer:(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>)
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vwt:<span class="hljs-type"><span class="hljs-type">ValueWitnessTable</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pwt:<span class="hljs-type"><span class="hljs-type">DrawableProtocolWitnessTable</span></span>
}

<span class="hljs-comment"><span class="hljs-comment">// drawACopy方法生成的伪代码</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val:ExistContDrawable)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//将existential container传入</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> local = <span class="hljs-type"><span class="hljs-type">ExistContDrawable</span></span>()  <span class="hljs-comment"><span class="hljs-comment">//初始化container</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vwt = val.vwt <span class="hljs-comment"><span class="hljs-comment">//获取value witness table，用于管理生命周期</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pwt = val.pwt <span class="hljs-comment"><span class="hljs-comment">//获取protocol witness table，用于进行方法分派</span></span>
 local.type = type 
 local.pwt = pwt
 vwt.allocateBufferAndCopyValue(&amp;local, val)  <span class="hljs-comment"><span class="hljs-comment">//vwt进行生命周期管理，初始化或者拷贝</span></span>
 pwt.draw(vwt.projectBuffer(&amp;local)) <span class="hljs-comment"><span class="hljs-comment">//pwt查找方法，这里说一下projectBuffer，因为不同类型在内存中是不同的（small value内联在栈内，large value初始化在堆内，栈持有指针），所以方法的确定也是和类型相关的，我们知道，查找方法时是通过当前对象的地址，通过一定的位移去查找方法地址。</span></span>
 vwt.destructAndDeallocateBuffer(temp) <span class="hljs-comment"><span class="hljs-comment">//vwt进行生命周期管理，销毁内存</span></span>
}
</code></pre><h3 id="protocol-type-存储属性">Protocol Type 存储属性</h3><p>我们知道，Swift中<code>Class</code>的实例和属性都存储在堆区，<code>Struct</code>实例在栈区，如果包含指针属性则存储在堆区，<code>Protocol Type</code>如何存储属性？Small Number通过<code>Existential Container</code>内联实现，大数存在堆区。如何处理Copy呢？</p><h4 id="protocol大数的copy优化">Protocol大数的Copy优化</h4><p>在出现Copy情况时：</p><pre><code class="hljs properties"><span class="hljs-attr"><span class="hljs-attr">let</span></span> <span class="hljs-string"><span class="hljs-string">aLine = Line(1.0, 1.0, 1.0, 3.0)</span></span>
<span class="hljs-attr"><span class="hljs-attr">let</span></span> <span class="hljs-string"><span class="hljs-string">pair = Pair(aLine, aLine)</span></span>
<span class="hljs-attr"><span class="hljs-attr">let</span></span> <span class="hljs-string"><span class="hljs-string">copy = pair</span></span>
</code></pre><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/ffef3229.png" alt="Protocol Type Copy Large Number"><div class="img-figure"><span>Protocol Type Copy Large Number</span></div></p><p>会将新的<code>Exsitential Container</code>的valueBuffer指向同一个value即创建指针引用，但是如果要改变值怎么办?我们知道<code>Struct</code>值的修改和<code>Class</code>不同，Copy是不应该影响原实例的值的。</p><p>这里用到了一个技术叫做<code>Indirect Storage With Copy-On-Write</code>，即优先使用内存指针。通过提高内存指针的使用，来降低堆区内存的初始化。降低内存消耗。在需要修改值的时候，会先检测引用计数检测，如果有大于1的引用计数，则开辟新内存，创建新的实例。在对内容进行变更的时候，会开启一块新的内存，伪代码如下：</p><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LineStorage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2:<span class="hljs-type"><span class="hljs-type">Double</span></span> }
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storage :<span class="hljs-type"><span class="hljs-type">LineStorage</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(<span class="hljs-type"><span class="hljs-type">Point</span></span>(), <span class="hljs-type"><span class="hljs-type">Point</span></span>()) }
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { … }
 <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {
   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isUniquelyReferencedNonObjc(&amp;storage) { <span class="hljs-comment"><span class="hljs-comment">//如何存在多份引用，则开启新内存，否则直接修改</span></span>
     storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(storage)
   }
   storage。start = ...
   }
}
</code></pre><p>这样实现的目的：通过多份指针去引用同一份地址的成本远远低于开辟多份堆内存。以下对比图：</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/06227fbe.png" alt="堆拷贝"><div class="img-figure"><span>堆拷贝</span></div></p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/6689b674.png" alt="Indirect Storage"><div class="img-figure"><span>Indirect Storage</span></div></p><h4 id="protocol-type多态总结">Protocol Type多态总结</h4><ol><li><p>支持<code>Protocol Type</code>的动态多态（<code>Dynamic Polymorphism</code>）行为。</p></li><li><p>通过使用<code>Witness Table</code>和<code>Existential Container</code>来实现。</p></li><li><p>对于大数的拷贝可以通过<code>Indirect Storage</code>间接存储来进行优化。</p></li></ol><p>说到动态多态<code>Dynamic Polymorphism</code>，我们就要问了，什么是静态多态<code>Static Polymorphism</code>，看看下面示例：</p><pre><code class="hljs swift"><span class="hljs-comment"><span class="hljs-comment">// Drawing a copy</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>
}
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local :Drawable)</span></span></span></span> {
 local.draw()
}

<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line = <span class="hljs-type"><span class="hljs-type">Line</span></span>()
drawACopy(line)
<span class="hljs-comment"><span class="hljs-comment">// ...</span></span>
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>()
drawACopy(point)
</code></pre><p>这种情况我们就可以用到<strong>泛型</strong><code>Generic code</code>来实现，进行进一步优化。</p><h2 id="泛型">泛型</h2><p>我们接下来会讨论泛型属性的存储方式和泛型方法是如何分派的。泛型和<code>Protocol Type</code>的区别在于：</p><ul><li>泛型支持的是静态多态。</li><li>每个调用上下文只有一种类型。
查看下面的示例，<code>foo</code>和<code>bar</code>方法是同一种类型。</li><li>在调用链中会通过类型降级进行类型取代。</li></ul><p>对于以下示例：</p><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">&lt;T:Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local :T)</span></span></span></span> {
 bar(local)
}
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">&lt;T:Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local:T)</span></span></span></span> { … }
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>()
foo(point)
</code></pre><p>分析方法<code>foo</code>和<code>bar</code>的调用过程：</p><pre><code class="hljs rust"><span class="hljs-comment"><span class="hljs-comment">//调用过程</span></span>
foo(point)--&gt;foo&lt;T = Point&gt;(point)   <span class="hljs-comment"><span class="hljs-comment">//在方法执行时，Swift将泛型T绑定为调用方使用的具体类型，这里为Point</span></span>
 bar(local) --&gt;bar&lt;T = Point&gt;(local) <span class="hljs-comment"><span class="hljs-comment">//在调用内部bar方法时，会使用foo已经绑定的变量类型Point，可以看到，泛型T在这里已经被降级，通过类型Point进行取代</span></span>
</code></pre><p>泛型方法调用的具体实现为：</p><ul><li>同一种类型的任何实例，都共享同样的实现，即使用同一个Protocol Witness Table。</li><li>使用Protocol/Value Witness Table。</li><li>每个调用上下文只有一种类型：这里没有使用<code>Existential Container</code>， 而是将<code>Protocol/Value Witness Table</code>作为调用方的额外参数进行传递。</li><li>变量初始化和方法调用，都使用传入的<code>VWT</code>和<code>PWT</code>来执行。</li></ul><p>看到这里，我们并不觉得泛型比<code>Protocol Type</code>有什么更快的特性，泛型如何更快呢?静态多态前提下可以进行进一步的优化，称为<strong>特定泛型</strong>优化。</p><h3 id="泛型特化">泛型特化</h3><ul><li>静态多态：在调用栈中只有一种类型。
Swift使用只有一种类型的特点，来进行类型降级取代。</li><li>类型降级后，产生特定类型的方法。</li><li>为泛型的每个类型创造对应的方法。这时候你可能会问，那每一种类型都产生一个新的方法，代码空间岂不爆炸?</li><li>静态多态下进行<strong>特定优化</strong> <code>specialization</code> 。
因为是静态多态。所以可以进行很强大的优化，比如进行内联实现，并且通过获取上下文来进行更进一步的优化。从而降低方法数量。优化后可以更精确和具体。</li></ul><p>例如：</p><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-function">&lt;T:Comparable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x:T, y:T)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> {
  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y &lt; x ? y : x
}
</code></pre><p>从普通的泛型展开如下，因为要支持所有类型的<code>min</code>方法，所以需要对泛型类型进行计算，包括初始化地址、内存分配、生命周期管理等。除了对value的操作，还要对方法进行操作。这是一个非常复杂庞大的工程。</p><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-function">&lt;T:Comparable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x:T, y:T, FTable:FunctionTable)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> {
  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xCopy = <span class="hljs-type"><span class="hljs-type">FTable</span></span>.copy(x)
  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yCopy = <span class="hljs-type"><span class="hljs-type">FTable</span></span>.copy(y)
  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> m = <span class="hljs-type"><span class="hljs-type">FTable</span></span>.lessThan(yCopy， xCopy) ? y :x
  <span class="hljs-type"><span class="hljs-type">FTable</span></span>.release(x)
  <span class="hljs-type"><span class="hljs-type">FTable</span></span>.release(y)
  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m
}
</code></pre><p>在确定入参类型时，比如Int，编译器可以通过泛型特化，进行类型取代（Type Substitute），优化为：</p><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-function">&lt;Int&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x:Int, y:Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> {
  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y &lt; x ? y :x
}
</code></pre><p><strong>泛型特化</strong><code>specilization</code>是何时发生的?</p><p>在使用特定优化时，调用方需要进行类型推断，这里需要知晓类型的上下文，例如类型的定义和内部方法实现。如果调用方和类型是单独编译的，就无法在调用方推断类型的内部实行，就无法使用特定优化，保证这些代码一起进行编译，这里就用到了<code>whole module optimization</code>。而<code>whole module optimization</code>是对于调用方和被调用方的方法在不同文件时，对其进行泛型特化优化的前提。</p><h3 id="泛型进一步优化">泛型进一步优化</h3><p>特定泛型的进一步优化：</p><pre><code class="hljs swift"><span class="hljs-comment"><span class="hljs-comment">// Pairs in our program using generic types</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class">&gt; </span></span>{
 <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span> f:<span class="hljs-type"><span class="hljs-type">T</span></span>， <span class="hljs-number"><span class="hljs-number">_</span></span> s:<span class="hljs-type"><span class="hljs-type">T</span></span>) {
 first = f ; second = s
 }
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first:<span class="hljs-type"><span class="hljs-type">T</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second:<span class="hljs-type"><span class="hljs-type">T</span></span>
}
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pairOfLines = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Line</span></span>(), <span class="hljs-type"><span class="hljs-type">Line</span></span>())
<span class="hljs-comment"><span class="hljs-comment">// ...</span></span>

<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pairOfPoint = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Point</span></span>(), <span class="hljs-type"><span class="hljs-type">Point</span></span>())
</code></pre><p>在用到多种泛型，且确定<strong>泛型类型不会在运行时修改</strong>时，就可以对成对泛型的使用进行进一步优化。</p><p>优化的方式是将泛型的内存分配由指针指定，变为内存内联，不再有额外的堆初始化消耗。请注意，因为进行了存储内联，已经确定了泛型特定类型的内存分布，泛型的内存内联不能存储不同类型。所以再次强调<strong>此种优化只适用于在运行时不会修改泛型类型</strong>，即不能同时支持一个方法中包含<code>line</code>和<code>point</code>两种类型。</p><h3 id="whole-module-optimization">whole module optimization</h3><p><code>whole module optimization</code>是用于Swift编译器的优化机制。可以通过<code>-whole-module-optimization</code> （或 <code>-wmo</code>）进行打开。在XCode 8之后默认打开。 <code>Swift Package Manager</code>在release模式默认使用<code>whole module optimization</code>。module是多个文件集合。</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/36e45899.png" alt="没有进行全模块优化"><div class="img-figure"><span>没有进行全模块优化</span></div></p><p>编译器在对源文件进行语法分析之后，会对其进行优化，生成机器码并输出目标文件，之后链接器联合所有的目标文件生成共享库或可执行文件。</p><p><code>whole module optimization</code>通过跨函数优化，可以进行内联等优化操作，对于泛型，可以通过获取类型的具体实现来进行推断优化，进行类型降级方法内联，删除多余方法等操作。</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/2a5e41a0.png" alt="whole module optimizaiton"><div class="img-figure"><span>whole module optimizaiton</span></div></p><p><strong>全模块优化的优势</strong></p><ul><li>编译器掌握所有方法的实现，可以进行<strong>内联</strong>和<strong>泛型特化</strong>等优化，通过计算所有方法的引用，移除多余的引用计数操作。</li><li>通过知晓所有的非公共方法，如果这写方法没有被使用，就可以对其进行消除。</li></ul><p><strong>如何降低编译时间</strong></p><p>和全模块优化相反的是文件优化，即对单个文件进行编译。这样的好处在于可以并行执行，并且对于没有修改的文件不会再次编译。缺点在于编译器无法获知全貌，无法进行深度优化。下面我们分析下全模块优化如何避免没修改的文件再次编译。</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/0a9908b5.png" alt="避免recompile"><div class="img-figure"><span>避免recompile</span></div></p><p>编译器内部运行过程分为：语法分析，类型检查，<code>SIL</code>优化，<code>LLVM</code>后端处理。</p><p>语法分析和类型检查一般很快，<code>SIL</code>优化执行了重要的Swift特定优化，例如泛型特化和方法内联等，该过程大概占用整个编译时间的三分之一。<code>LLVM</code>后端执行占用了大部分的编译时间，用于运行降级优化和生成代码。</p><p>进行全模块优化后，<code>SIL</code>优化会将模块再次拆分为多个部分，<code>LLVM</code>后端通过多线程对这些拆分模块进行处理，对于没有修改的部分，不会进行再处理。这样就避免了修改一小部分，整个大模块进行<code>LLVM</code>后端的再次执行，除此外，使用多线程并行操作也会缩短处理时间。</p><h2 id="扩展-swift的隐藏-bug">扩展：Swift的隐藏“Bug”</h2><p>Swift因为方法分派机制问题，所以在设计和优化后，会产生和我们常规理解不太一致的结果，这当然不能算Bug。但是还是要单独进行说明，避免在开发过程中，因为对机制的掌握不足，造成预期和执行出入导致的问题。</p><p><strong>Message dispatch</strong></p><p>我们通过上面说明结合<a href="https://www.jianshu.com/p/e0659093eaac">Static dispatch VS Dynamic dispatch<i class="fa fa-link" aria-hidden="true"></i></a>对方法分派方式有了了解。这里需要对<code>Objective-C</code>的方法分派方式进行说明。</p><p>熟悉OC的人都知道，OC采用了运行时机制使用<code>obj_msgSend</code>发送消息，runtime非常的灵活，我们不仅可以对方法调用采用<code>swizzling</code>，对于对象也可以通过<code>isa-swizzling</code>来扩展功能，应用场景有我们常用的hook和大家熟知的<code>KVO</code>。</p><p>大家在使用Swift进行开发时都会问，Swift是否可以使用OC的运行时和消息转发机制呢？答案是可以。</p><p>Swift可以通过关键字<code>dynamic</code>对方法进行标记，这样就会告诉编译器，此方法使用的是OC的运行时机制。</p><blockquote class="with-icon"><i class="fa fa-quote-left post-blockquote-icon"></i><i class="fa fa-quote-left post-blockquote-icon"></i><p>注意：我们常见的关键字<code>@ObjC</code>并不会改变Swift原有的方法分派机制，关键字<code>@ObjC</code>的作用只是告诉编译器，该段代码对于OC可见。</p></blockquote><p>总结来说，Swift通过<code>dynamic</code>关键字的扩展后，一共包含三种方法分派方式：<code>Static dispatch</code>，<code>Table dispatch</code>和<code>Message dispatch</code>。下表为不同的数据结构在不同情况下采取的分派方式：</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/fd34ea0b.png" alt="Swift Dispatch Method"><div class="img-figure"><span>Swift Dispatch Method</span></div></p><p>如果在开发过程中，错误的混合了这几种分派方式，就可能出现Bug，以下我们对这些Bug进行分析：</p><p><strong><a href="https://bugs.swift.org/browse/SR-584">SR-584<i class="fa fa-link" aria-hidden="true"></i></a></strong>
此情况是在子类的extension中重载父类方法时，出现和预期不同的行为。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NSObject {</span></span></span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> directProperty:String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"This is Base"</span></span> }
    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indirectProperty:String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> directProperty }
}

<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sub</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base { }</span></span></span></span>

extension Sub {
    <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> directProperty:String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"This is Sub"</span></span> }
}
</code></pre><p>执行以下代码，直接调用没有问题：</p><pre><code class="hljs less"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Base</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.directProperty</span></span> <span class="hljs-comment"><span class="hljs-comment">// “This is Base”</span></span>
<span class="hljs-selector-tag"><span class="hljs-selector-tag">Sub</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.directProperty</span></span> <span class="hljs-comment"><span class="hljs-comment">// “This is Sub”</span></span>
</code></pre><p>间接调用结果和预期不同：</p><pre><code class="hljs armasm"><span class="hljs-keyword"><span class="hljs-keyword">Base（）。indirectProperty </span></span>// “This is <span class="hljs-keyword"><span class="hljs-keyword">Base”
</span></span><span class="hljs-keyword"><span class="hljs-keyword">Sub（）。indirectProperty </span></span>// expected <span class="hljs-string"><span class="hljs-string">"this is Sub"</span></span>，<span class="hljs-keyword"><span class="hljs-keyword">but </span></span>is “This is <span class="hljs-keyword"><span class="hljs-keyword">Base” </span></span>&lt;- Unexpected!
</code></pre><p>在<code>Base.directProperty</code>前添加<code>dynamic</code>关键字就可以获得”this is Sub”的结果。Swift在<a href="https://docs.swift.org/Swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151">extension 文档<i class="fa fa-link" aria-hidden="true"></i></a>中说明，不能在extension中重载已经存在的方法。</p><blockquote class="with-icon"><i class="fa fa-quote-left post-blockquote-icon"></i><i class="fa fa-quote-left post-blockquote-icon"></i><p>“Extensions can add new functionality to a type, but they cannot override existing functionality.”</p></blockquote><p>会出现警告：<code>Cannot override a non-dynamic class declaration from an extension</code>。</p><p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/b89bb030.png" alt="Extension Override Warning"><div class="img-figure"><span>Extension Override Warning</span></div></p><p>出现这个问题的原因是，NSObject的extension是使用的<code>Message dispatch</code>，而<code>Initial Declaration</code>使用的是<code>Table dispath</code>（查看上图 Swift Dispatch Method）。extension重载的方法添加在了<code>Message dispatch</code>内，没有修改虚函数表，虚函数表内还是父类的方法，故会执行父类方法。想在extension重载方法，需要标明<code>dynamic</code>来使用<code>Message dispatch</code>。</p><p><strong><a href="https://bugs.swift.org/browse/SR-103">SR-103<i class="fa fa-link" aria-hidden="true"></i></a></strong></p><p>协议的扩展内实现的方法，无法被遵守类的子类重载：</p><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greetable</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>
}
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greetable</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {
        <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>）
    }
}
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greetings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(greeter：Greetable)</span></span></span></span> {
    greeter.sayHi()
}
</code></pre><p>现在定义一个遵守了协议的类<code>Person</code>。遵守协议类的子类<code>LoudPerson</code>：</p><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greetable</span></span></span><span class="hljs-class"> </span></span>{
}
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoudPerson</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {
        <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"sub"</span></span>)
    }
}
</code></pre><p>执行下面代码结果为：</p><pre><code class="hljs armasm"><span class="hljs-symbol"><span class="hljs-symbol">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub:LoudPerson </span></span>= LoudPerson()
<span class="hljs-keyword"><span class="hljs-keyword">sub.sayHi() </span></span> //<span class="hljs-keyword"><span class="hljs-keyword">sub
</span></span></code></pre><p>不符合预期的代码：</p><pre><code class="hljs typescript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sub:Person = LoudPerson()
sub.sayHi()  <span class="hljs-comment"><span class="hljs-comment">//HellO  &lt;-使用了protocol的默认实现</span></span>
</code></pre><p>注意，在子类<code>LoudPerson</code>中没有出现<code>override</code>关键字。可以理解为<code>LoudPerson</code>并没有成功注册<code>Greetable</code>在<code>Witness table</code>的方法。所以对于声明为<code>Person</code>实际为<code>LoudPerson</code>的实例，会在编译器通过<code>Person</code>去查找，<code>Person</code>没有实现协议方法，则不产生<code>Witness table</code>，<code>sayHi</code>方法是直接调用的。解决办法是在base类内实现协议方法，无需实现也要提供默认方法。或者将基类标记为<code>final</code>来避免继承。</p><p>进一步通过示例去理解：</p><pre><code class="hljs swift"><span class="hljs-comment"><span class="hljs-comment">// Defined protocol。</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span>
}
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> {
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>
    }
}

<span class="hljs-comment"><span class="hljs-comment">// A class doesn't have implement of the function。</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">：</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{}

<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">：</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> {
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>
    }
}

<span class="hljs-comment"><span class="hljs-comment">// A class has implement of the function。</span></span>
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">：</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> {
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>
    }
}

<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">：</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> {
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>
    }
}

<span class="hljs-comment"><span class="hljs-comment">// Failure cases。</span></span>
<span class="hljs-type"><span class="hljs-type">B</span></span>().a() <span class="hljs-comment"><span class="hljs-comment">// 0</span></span>
<span class="hljs-type"><span class="hljs-type">C</span></span>().a() <span class="hljs-comment"><span class="hljs-comment">// 1</span></span>
(<span class="hljs-type"><span class="hljs-type">C</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>).a() <span class="hljs-comment"><span class="hljs-comment">// 0 # We thought return 1。 </span></span>

<span class="hljs-comment"><span class="hljs-comment">// Success cases。</span></span>
<span class="hljs-type"><span class="hljs-type">D</span></span>().a() <span class="hljs-comment"><span class="hljs-comment">// 1</span></span>
(<span class="hljs-type"><span class="hljs-type">D</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>).a() <span class="hljs-comment"><span class="hljs-comment">// 1</span></span>
<span class="hljs-type"><span class="hljs-type">E</span></span>().a() <span class="hljs-comment"><span class="hljs-comment">// 2</span></span>
(<span class="hljs-type"><span class="hljs-type">E</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>).a() <span class="hljs-comment"><span class="hljs-comment">// 2</span></span>
</code></pre><p><strong>其他</strong></p><p>我们知道Class extension使用的是Static Dispatch：</p><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{
}
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extensionMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}
}
 
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubClass</span></span></span><span class="hljs-class">：</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extensionMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}
}
</code></pre><p>以上代码会出现错误，提示<code>Declarations in extensions can not be overridden yet</code>。</p><h2 id="总结">总结</h2><ul><li>影响程序的性能标准有三种：<strong>初始化方式</strong>， <strong>引用指针</strong>和<strong>方法分派</strong>。</li><li>文中对比了两种数据结构：<code>Struct</code>和<code>Class</code>的在不同标准下的性能表现。Swift相比OC和其它语言强化了结构体的能力，所以在了解以上性能表现的前提下，通过利用结构体可以有效提升性能。</li><li>在此基础上，我们还介绍了功能强大的结构体的类：<code>Protocol Type</code>和<code>Generic</code>。并且介绍了它们如何支持多态以及通过使用有条件限制的泛型如何让程序更快。</li></ul><h2 id="参考资料">参考资料</h2><ul><li><a href="https://developer.apple.com/documentation/swift/memorylayout">swift memorylayout<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://developer.apple.com/videos/play/wwdc2016/416/">witness table video<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2016/416k7f0xkmz28rvlvwb/416/416_understanding_swift_performance.pdf?dl=1">protocol types pdf<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://developer.apple.com/videos/play/wwdc2016/419">protocol and value oriented programming in UIKit apps video<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/409/">optimizing swift performance<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://swift.org/blog/whole-module-optimizations/">whole module optimizaiton<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://developer.apple.com/swift/blog/?id=27">increasing performance by reducing dynamic dispatch<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://medium.com/@vhart/protocols-generics-and-existential-containers-wait-what-e2e698262ab1">protocols generics existential container<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://airspeedvelocity.net/2015/03/26/protocols-and-generics-2/">protocols and generics<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://www.skilled.io/u/purpleyay/why-swift-is-swift">why swift is swift<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="http://raizlabs.wpengine.com/dev/2016/12/swift-method-dispatch/">swift method dispatch<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151">swift extension<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html">universal dynamic dispatch for method calls<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://github.com/apple/swift/blob/master/docs/CompilerPerformance.md">compiler performance.md<i class="fa fa-link" aria-hidden="true"></i></a></li><li><a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html">structures and classes<i class="fa fa-link" aria-hidden="true"></i></a></li></ul><h2 id="作者简介">作者简介</h2><ul><li>亚男，美团点评iOS工程师。2017年加入美团点评，负责专业版餐饮管家开发，研究编译器原理。目前正积极推动Swift组件化建设。</li></ul><h2 id="招聘信息">招聘信息</h2><p>我们餐饮生态技术部是一个技术氛围活跃，大牛聚集的地方。新到店紧握真正的大规模SaaS实战机会，多租户、数据、安全、开放平台等全方位的挑战。业务领域复杂技术挑战多，技术和业务能力迅速提升，最重要的是，加入我们，你将实现真正通过代码来改变行业的梦想。我们欢迎各端人才加入，Java优先。感兴趣的同学赶紧发送简历至 zhaoyanan02@meituan.com，我们期待你的到来。</p></div></div><div class="meta-box post-bottom-meta-box hidden-print"><span class="tag-links"><i class="fa fa-tags" aria-hidden="true"></i><a href="https://tech.meituan.com/tags/%E5%89%8D%E7%AB%AF.html" rel="tag">前端</a>, <a href="https://tech.meituan.com/tags/%E5%88%B0%E5%BA%97.html" rel="tag">到店</a>, <a href="https://tech.meituan.com/tags/ios.html" rel="tag">iOS</a>, <a href="https://tech.meituan.com/tags/swift.html" rel="tag">Swift</a>, <a href="https://tech.meituan.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8.html" rel="tag">编译器</a>, <a href="https://tech.meituan.com/tags/static-dispatch.html" rel="tag">Static dispatch</a>, <a href="https://tech.meituan.com/tags/dynamic-dispatch.html" rel="tag">Dynamic dispatch</a>, <a href="https://tech.meituan.com/tags/compile-0ptimization.html" rel="tag">Compile 0ptimization</a></span></div><div class="row page-navigation-container hidden-print"><div class="col-xs-12 col-sm-12 col-md-12 col-lg-12"><div class="navigation-wrapper"><div class="pager"><div class="title-box"><i class="fa fa-paperclip"></i>#看看其他</div><a href="https://tech.meituan.com/2018/11/01/cat-in-depth-java-application-monitoring.html" title="深度剖析开源分布式监控CAT" class="previous"><span aria-hidden="true">前一篇: 深度剖析开源分布式监控CAT</span></a>
<a href="https://tech.meituan.com/2018/11/01/cat-pr.html" title="CAT 3.0 开源发布，支持多语言客户端及多项性能提升" class="next"><span aria-hidden="true">后一篇: CAT 3.0 开源发布，支持多语言客户端及多项性能提升</span></a></div></div></div></div><div class="row page-comments-container hidden-print"><div class="col-xs-12 col-sm-12 col-md-12 col-lg-12"><div class="comments-wrapper hidden-print"><div id="comments" class="comments-disabled"><div class="title-box"><i class="fa fa-comments-o"></i>#一起聊聊</div><div class="post-feedback-box hidden-print"><p>如发现文章有错误、对内容有疑问，都可以关注美团技术团队微信公众号（meituantech），在后台给我们留言。</p><img class="qrcode" src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/b0364d579285ab22aa6235bd100d7c22178175.png" alt="美团技术团队微信二维码"><p class="follow-us">分享一线技术实践，沉淀成长学习经验</p></div></div></div></div></div></div></div></div></div><div class="container-fluid main-container" id="J_footer-container"><script>$CONFIG['data']['footerLink']=[{"name":"网站首页","link":"/"},{"name":"文章存档","link":"/archives"},{"name":"关于我们","link":"/about"}];</script><div class="row"><div class="col-md-12 footer-links-container"><div class="footer-divider"></div></div><div class="col-md-4"><p>一行代码，亿万生活。</p></div><div class="col-md-8"><ul class="nav nav-pills navbar-right"><li class="menu-item"><a href="https://tech.meituan.com/" title="">网站首页</a></li><li class="menu-item"><a href="https://tech.meituan.com/archives" title="">文章存档</a></li><li class="menu-item"><a href="https://tech.meituan.com/about" title="">关于我们</a></li></ul></div></div><div class="m-fixed-button"><div class="m-wrapper"><div class="m-qrcode"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsSAAALEgHS3X78AAAAjklEQVRIx81V2xHAIAjTnruyhmuwbb96Z6kYOJWaTx6SKGBm5poMIKJXnDXvsgTNoGgMrUxR3nYFnwLMXHusNTvyx73BA+1ONTvyb1eQvXNgjQ9T4EbbLaizQhQsKTBSsVyBvLbi7YoWaDZS6gzaDPNeUfM2lXOgHSjz4ncRYub92c7Zpgjnb1ON8e9vcAOBkF++GF/4vQAAAABJRU5ErkJggg=="></div><div class="m-go-top"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsSAAALEgHS3X78AAAB/ElEQVR42u3bX0rcUBiG8cc/o+5CwW5CL0rpJirY+2zDbZzbti6klXYhCm7B0Ssv7AfqJAMz7zk5n/A+VzMhTL78IOSQITullCvc1u32HuCjZ0AxA4oZUMyAYgYUM6CYAcUMKGZAMQOKGVDMgGIGFDOgmAHFDChmQDEDihlQzIBiBhQzoJgBxQwoZkAxA4rt9x5gTQ/Ab2AP+Awc9h5orKyAD8DPYRjuAUopt8AlcNR7sPdlvITf4AEMw3AHXAPL3sO9LxvgCl6UFTET4ApeKeVTKeUkvmdEzAI4igdcAJeZETMALpnG2wcWJEbsDbgEfozgfePtCiEtYk/AdXiLkf1TIvYC3BQvWof42ONEegBuixdNIf6iA+LcgCpelAZxTsAxvFM2x4tSIM4FOIV3wXZ4USAex4a5EecAbIUXLYDvvRBbA7bGi7ohtgScCy/qgtgKcG68aAqx2TqxBWAvvGgM8ZZGiLUBe+NFY3fnJog1AbPgRQdMIz7VOkhNwD+J8KIpxJtaB2hyE0mCF60g1myn4iv/j8BfXp7jnZED73VPwL//n895gZWr+bfmIfB1ZpRNOgC+1P7R3k+kP3wGFDOgmAHFDChmQDEDihlQzIBiBhQzoJgBxQwoZkAxA4oZUMyAYgYUM6CYAcUMKGZAMQOKGVDMgGIGFDOg2DOEU/uBJ0Ro/gAAAABJRU5ErkJggg=="></div></div><div class="qrcode-container"><div class="qr_code"><p class="desktop_qr_tittle">扫码关注技术博客</p><img src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/7d0f734bcd029f452d415ce7d521a0d9632811.gif" class="qr_img"></div></div></div></div><script src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/post.js"></script><script async="" src="./【基本功】深入剖析Swift性能优化 - 美团技术团队_files/js(2)"></script><script>try{window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-55279261-1');}catch(e){}</script><script>try{var _hmt=_hmt||[];var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?7158c55a533ed0cf57dede022b1e6aed";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);}catch(e){}</script></body><grammarly-desktop-integration data-grammarly-shadow-root="true"></grammarly-desktop-integration></html>