---
title: 00. Common higher-order functions
date: 2023-11-11 20:00:00
categories: 
- [Swift, Collections]
tags:
- map
- reduce
- filter
- flatMap
---

<font color=gray size=2>*It will take about 3 minutes to finish reading this article.*</font>

This zip function is not used to compress files. It is used to merge the elements of two sequences one by one to generate a new sequence.

#### <font size=5 color=#4169E1>1. map</font> 

Map is a common higher-order function that maps each element in a collection to another collection and then returns a new collection.

```Swift

let a = [1, 2, 3, 4, 5]
let b = a.map { $0 * 2 }
print(b) // [2, 4, 6, 8, 10]

```

In this example, we multiply each element in the original array by 2 and store the result in a new array.

We can customize its custom implementation and write it into the Array extension:

```Swift
func customMap<T>(_ tansform:(Element)->T) -> [T] {
    var result: [T] = []
    for x in self {
        result.append(tansform(x))
    }
    return result
}
```

The call is as follows:

```Swift
let a = [1, 2, 3, 4, 5]
let b = a.customMap { $0 * 2 }
print(b) // [2, 4, 6, 8, 10]

```

#### <font size=5 color=#4169E1>2. reduce</font> 

reduce is another common higher-order function that combines all elements in a collection into a single value. Its usage is as follows:

```Swift
let a = [1, 2, 3, 4, 5]
let b = a.reduce(0) { $0 + $1 }
print(b) // 15

```
In this example, we add all the elements in the original array and store the result in a variable.

The custom implementation is as follows:

```Swift

func customReduce<T>(_ initial:T, _ combine: (T, Element)->T) -> T {
    var result = initial
    for x in self {
        result = combine(result, x)
    }
    return result
}

```
The call is as follows:

```Swift
let a = [1, 2, 3, 4, 5]
let b = b.customReduce(0, +)
print(b) // 15

```

#### <font size=5 color=#4169E1>3. filter</font> 

Filter is a common high-order function that can filter out elements that meet conditions from a set and then return a new set. Its usage is as follows:

```Swift
let a = [1, 2, 3, 4, 5]
let b = a.filter { $0 % 2 == 0 }
print(b) // [2, 4]

```

In this example, we filter out all even elements in the original array and store the results in a new array.

The custom implementation is as follows:

```Swift
func customFilter(_ isInclude:(Element) -> Bool) ->[Element] {
    var result: [Element] = []
    for x in self where isInclude(x) {
        result.append(x)
    }
    return result
}

```

The call is as follows:

```Swift
let a = [1, 2, 3, 4, 5]
let b = a.customFilter { $0 % 2 == 0 }
print(b) // [2, 4]

```

#### <font size=5 color=#4169E1>4. flatMap</font> 

flatMap is a common higher-order function that flattens a nested collection into a single collection. Its usage is as follows:

```Swift
let a = [[1, 2], [3, 4], [5, 6]]
let b = a.flatMap { $0 }
print(b) // [1, 2, 3, 4, 5, 6]

```

In this example, we flatten an array of three arrays into a single array and store the result in a new array.

Its custom implementation is as follows:

```Swift
func customFlatMap<T>(_ transform: (Element) -> [T]) -> [T] {
    var tmp: [T] = []
    for value in self {
       tmp.append(contentsOf: transform(value))
    }
    return tmp
}

```

```Swift
let a = ["a", "b", "c", "d"]
let b = ["A", "B", "C", "D"]
let c = [a, b].flatMap({ $0 })
let d = [a, b].customFlatMap({ $0 })
print (c) //["a", "b", "c", "d", "A", "B", "C", "D"]
print (d) //["a", "b", "c", "d", "A", "B", "C", "D"]
```