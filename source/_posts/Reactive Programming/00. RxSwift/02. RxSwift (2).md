---
title: 02. RxSwift (2) ———— Basic Operations
date: 2023-09-22 16:00:00
categories: 
- [Reactive Programming, 00. RxSwift]
tags:
- RxSwift
---

<font color=gray size=2>*It will take about 5 minutes to finish reading this article.*</font>

#### <font size=3 color=#4169E1>1. DisposeBag</font>

Garbage collection bag, DisposeBag is actually equivalent to ARC in iOS, it will destroy the observer at the appropriate time, a memory management mechanism of RxSwift.

```Swift
let disposeBag = DisposeBag()
```



#### <font size=3 color=#4169E1>2. Common basic operations</font> 

<font size=3 color=#4169E1>**2.1 never**</font>  

never is a special entity used to create an Observable that never terminates. This Observable will not emit any elements, nor will it emit error or completion events. Typically used to indicate a situation that persists but does not emit any events. Because it never terminates, care needs to be taken when subscribing to take appropriate steps to handle unsubscription situations.

{% img /assets/ReactiveProgramming/RxSwift/01.jpeg %}

```Swift
func example00() {
    Observable<String>.never()
    .subscribe { _ in
         print("This will not be executed here...")
     }.disposed(by: disposeBag)
}
```

<font size=3 color=#4169E1>**2.2 empty**</font>  

Used to create an empty Observable that does not emit any elements or events, i.e. it is an Observable that completes immediately. Usually used to indicate that the result of some operation is empty or does not produce any value. The sequence created by empty can only emit one completed event.

```Swift
func example01() {
    Observable<Int>.empty()
    .subscribe { event in
        print(event)
    }.disposed(by: disposeBag)
}
//Result：
completed
```

<font size=3 color=#4169E1>**2.3 just**</font>

It is used to create an Observable sequence containing only a single element. just takes an argument and emits that argument as an element, creating an Observable containing a single element. Typically used to convert a single value or object to an Observable.

{% img /assets/ReactiveProgramming/RxSwift/02.jpeg %}

```Swift
func example02() {
    Observable.just("?")
    .subscribe { event in
        print(event)
    }.disposed(by: disposeBag)
}
//Result:
next(?)
completed
```

<font size=3 color=#4169E1>**2.4 of**</font>

Used to pass multiple elements as parameters, and then emit these elements in sequence to create an Observable sequence containing these elements. This operator is ideal for creating an Observable containing static data.

```Swift
func example03() {
    Observable.of("?", "?", "?", "?")
    .subscribe(onNext: { element in
        print(element)
    }).disposed(by: disposeBag)
}
//Result:
?
?
?
?
```

If you remove onNext: above, the result will be like this, which corresponds to our subscribe. Subscribe only listens for events. The execution results are as follows:

```Swift
next(?)
next(?)
next(?)
next(?)
completed
```

<font size=3 color=#4169E1>**2.5 from**</font>

Used to convert an array, sequence, or enumerable object into an Observable, emitting its elements in sequence. It is suitable for converting an existing collection of data into an observable sequence.

```Swift
func example04() {
    Observable.from(["1", "2", "3", "4"])
    .subscribe(onNext: { print($0) })
    .disposed(by: disposeBag)
}
//Result:
1
2
3
4
```

<font size=3 color=#4169E1>**2.6 create**</font>

Method for creating a custom Observable. The create method gives you complete control over the behavior of the Observable, including when to emit element, error, or completion events. This allows you to create highly customized Observables to meet specific needs.

{% img /assets/ReactiveProgramming/RxSwift/03.jpeg %}

The create operator passes in an observer, and then calls the observer's onNext, onCompleted, and onError methods. Returns an observable sequence.
```Swift
func example05() {
    let myJust = { (element: String) -> Observable<String> in
        return Observable.create { observer in
            observer.on(.next(element))
            observer.on(.completed)
            return Disposables.create()
        }
    }

    myJust("?")
    .subscribe { print($0) }
    .disposed(by: disposeBag)
}
//Result:
next(?)
completed
```

<font size=3 color=#4169E1>**2.7 range**</font>

Factory function for creating an Observable that emits a sequence of integers within a range. The range operator generates an Observable sequence that emits consecutive integers starting at a specified starting value until a specified number or ending value is reached.

{% img /assets/ReactiveProgramming/RxSwift/04.jpeg %}

```Swift
func example06() {
    Observable.range(start: 3, count: 5)
    .subscribe { print($0) }
    .disposed(by: disposeBag)
}
//Result:
next(3)
next(4)
next(5)
next(6)
next(7)
completed
```

<font size=3 color=#4169E1>**2.8 repeatElement**</font>

Factory function for creating an Observable that emits the specified element repeatedly indefinitely. It generates a sequence of Observables that emit the same elements until you explicitly stop it.

{% img /assets/ReactiveProgramming/RxSwift/05.jpeg %}

```Swift
func example07() {
    Observable.repeatElement("#")
    .take(3)
    .subscribe(onNext: { print($0) })
    .disposed(by: disposeBag)
}
//Result:
#
#
#
```

<font size=3 color=#4169E1>**2.9 generate**</font>

Generates elements in an Observable sequence according to specified logic, and allows you to customize how the elements are generated. The generate operator allows you to define the starting state of generated elements, incrementing logic, and when to terminate generation. The observable sequence created by generate will emit the corresponding event when the initialization condition is true.

```Swift
func example08() {
    Observable.generate(
        initialState: 0,
        condition: { $0 < 3 },
        iterate: { $0 + 1 }
    )
    .subscribe(onNext: { print($0) })
    .disposed(by: disposeBag)
}
//Result
0
1
2
```

<font size=3 color=#4169E1>**2.10 deferred**</font>

Used to delay the creation of an Observable until an observer subscribes to it. This means that every time an observer subscribes, the specified closure is executed to create a new Observable. Note: Deferred will create a new observable sequence for each subscriber observer.

{% img /assets/ReactiveProgramming/RxSwift/06.jpeg %}

```Swift
func example09() {
    var count = 1
    let deferredSequence = Observable<String>.deferred {
        print("Creating \(count)")
        count += 1

        return Observable.create { observer in
            print("Emitting...")
            observer.onNext("?")
            observer.onNext("?")
            observer.onNext("?")
            return Disposables.create()
        }
    }

    deferredSequence
    .subscribe(onNext: { print($0) })
    .disposed(by: disposeBag)

    deferredSequence
    .subscribe(onNext: { print($0) })
    .disposed(by: disposeBag)
}
//Result
Creating 1
Emitting...
?
?
?
Creating 2
Emitting...
?
?
?
```

In the above example, a new deferredSequence will be created every time you subscribe, so Emitting will be printed twice.

<font size=3 color=#4169E1>**2.11 error**</font>

Indicates that an error occurred during the Observable's life cycle. When an Observable encounters an error condition that prevents it from continuing to emit elements normally, it emits an error event and passes the error information to the observer. It creates an observable sequence but does not emit any normal events, only the error event and ends.

```Swift
func example10() {
    Observable<Int>.error(TestError.test) //Custom Error subclasses
    .subscribe { print($0) }
    .disposed(by: disposeBag)
}
//Result:
error(test)
```

<font size=3 color=#4169E1>**2.12 doOn**</font>

Used to add a side-effect behavior that performs a specified operation when certain events in the Observable's life cycle occur, but does not change the elements in the Observable.

The feeling of doOn is to execute a certain method first when directly processing onNext. The doOnNext(:) method is called before subscribe(onNext:), and doOnCompleted(:) is called before subscribe(onCompleted:).

```Swift
func example11() {
    Observable.of("1", "2", "3", "4")
    .do(onNext: { print("Intercepted:", $0) }, onError: { print("Intercepted error:", $0) }, onCompleted: { print("Completed")  })
    .subscribe(onNext: { print($0) },onCompleted: { print("Finished") })
    .disposed(by: disposeBag)
}
//Result:
Intercepted: 1
1
Intercepted: 2
2
Intercepted: 3
3
Intercepted: 4
4
Completed
Finished
```
